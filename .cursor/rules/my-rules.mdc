---
description: RÃ¨gles Cursor â€” stabilitÃ©, hygiÃ¨ne tests/Jupyter, qualitÃ© & sÃ©curitÃ©
alwaysApply: true
---

# ğŸ§­ PRINCIPES
- PrioritÃ© Ã  la **stabilitÃ©** et au pÃ©rimÃ¨tre minimal des changements.
- Toujours **lire le contexte** (README, docs/, ADR, commentaires, scripts) **avant** dâ€™implÃ©menter.
- **Citer les sources** (chemin:ligne) qui justifient chaque dÃ©cision technique.
- **Jamais** de secrets / URLs prod / API keys en dur. Configuration uniquement via variables dâ€™environnement.

# â˜… Mode : Plan â†’ Validation â†’ ExÃ©cution  
Tout changement doit dÃ©buter par une **proposition de plan** (fichiers concernÃ©s, diff attendu, risques, tests).  
Lâ€™agent ne doit **pas passer Ã  lâ€™implÃ©mentation** sans ton **accord explicite**.  
Avant dâ€™implÃ©menter :  
- lâ€™agent prÃ©sente le plan complet,  
- tu donnes ton **avis** (OK pour exÃ©cuter / modifications demandÃ©es),  
- puis lâ€™agent **exÃ©cute**.  
Ã€ la fin : lâ€™agent rapporte pour **validation finale** avant merge.

# ğŸ“‹ Check-liste de validation utilisateur (Ã  prÃ©senter avant exÃ©cution)  
- [ ] Ai-je bien compris le pÃ©rimÃ¨tre exact des changements demandÃ©s ?  
- [ ] Le plan liste les **fichiers impactÃ©s** + un **diff Ã©chantillon** pour chacun.  
- [ ] Les **risques** et **tests nÃ©cessaires** sont identifiÃ©s.  
- [ ] Je confirme que **le pÃ©rimÃ¨tre est minimal** et quâ€™aucun refactor hors-scope nâ€™est proposÃ©.  
- [ ] Le plan mentionne clairement les **fichiers non modifiÃ©s** (pour Ã©viter les effets collatÃ©raux).  
- [ ] Les conventions (tests, Jupyter, logs, variables env) sont respectÃ©es.  
- [ ] JE DONNE MON AVIS (OK ou demander modification) **avant que lâ€™agent implÃ©mente**.  
- [ ] Je donne explicitement mon **accord Â« OK, exÃ©cuter Â»** pour passer Ã  lâ€™implÃ©mentation.

# ğŸ“š CONTEXTE & SOURCES
- Utiliser les rÃ©fÃ©rences de forme `@workspace` pour explorer globalement ; `@file` pour cibler ; `@docs` pour rÃ©fÃ©rencer.
- Avant toute Ã©criture : lister les fichiers impactÃ©s + **diff** sur un **Ã©chantillon** ; attendre confirmation explicite.

# ğŸ”„ WORKFLOW SYSTÃ‰MATIQUE
1) **Analyser â†’ Rechercher lâ€™existant â†’ Proposer un plan minimal** (fichiers, diff, risques, tests).  
2) **ImplÃ©menter** lâ€™incrÃ©ment validÃ© uniquement.  
3) **Valider** (tests, lint/format) puis **nettoyer** (artifacts temporaires).  
4) **Documenter** les dÃ©cisions non Ã©videntes (notes ou ADR courtes).  
5) **SuggÃ©rer** les amÃ©liorations futures (sans implÃ©menter).

# ğŸ¯ PORTÃ‰E DES CHANGEMENTS
- Limiter strictement au pÃ©rimÃ¨tre demandÃ©.  
- **INTERDIT sans validation** : refactoring hors-scope, renommages massifs, reformatage de fichiers non touchÃ©s, optimisations opportunistes.

# ğŸ§± FICHIERS & FACTORISATION
- **Avant de crÃ©er un fichier** : rechercher Ã©quivalents (`@workspace` / `@file`), Ã©tendre/rÃ©utiliser si possible.  
- CrÃ©er **uniquement** si aucune structure adaptÃ©e nâ€™existe, avec justification courte.  
- Factoriser les duplications avÃ©rÃ©es vers helpers/services existants (ou nouveau module dÃ©diÃ© **aprÃ¨s** validation).

# ğŸ“ DOCUMENTATION (.md) â€” PRINCIPE Dâ€™ENRICHISSEMENT  
- Avant de **crÃ©er** un nouveau fichier de documentation `.md`, **vÃ©rifier** sâ€™il existe dÃ©jÃ  un ou plusieurs fichiers `.md` pertinents (README, docs/â€¦, etc).  
- Si un fichier existe : **prÃ©fÃ©rer lâ€™enrichissement** (ajout dâ€™informations pertinentes) plutÃ´t que la crÃ©ation dâ€™un nouveau fichier.  
- Veiller Ã  **ne pas surcharger** la documentation existante :  
  - maintenir la clartÃ© et lisibilitÃ© ;  
  - Ã©viter les duplications dâ€™informations ;  
  - dÃ©couper ou rÃ©fÃ©rencer si lâ€™ajout devient volumineux.  
- Si aucun fichier pertinent nâ€™existe aprÃ¨s vÃ©rification exhaustive, **alors** proposer la crÃ©ation dâ€™un nouveau fichier `.md`, avec justification dans le plan.

# ğŸ§ª TESTS â€” ASK-FIRST + AUTO-CLEAN
- **Ne JAMAIS crÃ©er** de tests sans validation explicite.  
- **Avant crÃ©ation/modif de tests**, PROPOSER :  
  - plan de couverture (unit/contract/e2e), emplacements, conventions de noms ;  
  - un **diff** minimal pour un fichier exemple ;  
  - puis **attendre Â« OK, crÃ©er Â»**.  
- **Nettoyage automatique (aprÃ¨s exÃ©cution)** :  
  - Supprimer uniquement les **brouillons temporaires** et sorties connues :  
    - patterns : `*.test.tmp*`, `*.spec.tmp*`, `tests/tmp/**`, `test-output/**`, `.nyc_output/`, `coverage/`, `.pytest_cache/`, `.coverage*`  
  - Commande Ã  exÃ©cuter : `@terminal: npm run test:clean` (ou `make test-clean`)  
  - Si le script nâ€™existe pas : **proposer** de lâ€™ajouter au projet (sans crÃ©er sans accord).  
- **Jamais** committer de fichiers correspondant aux patterns ci-dessus.  
- **Interdire le merge** si tests rouges : sâ€™appuyer sur les checks CI requis (voir section Git & revue).

# ğŸ““ JUPYTER â€” ASK-FIRST + NO-OUTPUTS + PAIRING
- **Ne JAMAIS** crÃ©er/modifier un `.ipynb` ou ajouter des cellules sans demande explicite.  
- **Avant toute action notebook**, PROPOSER :  
  - titre + chemin du fichier ;  
  - **format â€œpaireâ€** `ipynb,py:light` (Jupytext) ;  
  - aperÃ§u des 1â€“2 premiÃ¨res cellules ;  
  - politique **no-outputs** (sorties retirÃ©es au commit).  
- **Toujours** nettoyer les sorties avant commit (nbstripout).  
- Pour toute nouvelle paire : **proposer** dâ€™activer la synchro Jupytext (sans crÃ©er sans accord).

# ğŸ”§ QUALITÃ‰ AUTOMATISÃ‰E
- Respecter le style existant ; **ne pas reformater en masse** hors pÃ©rimÃ¨tre.  
- Faire tourner **lint + format** avant PR.  
- Si manquants, **proposer** (sans imposer) :  
  - `.editorconfig` (indentation, EOL, encodage) ;  
  - **Prettier** (format) + **ESLint** (flat config si JS/TS) ;  
  - hooks prÃ©-commit (pre-commit ou Husky + lint-staged) pour ne traiter que les fichiers stagÃ©s.

# âš¡ ERREURS & LOGS
- Try/catch explicite sur opÃ©rations Ã  risque (I/O, rÃ©seau, parsing).  
- Messages dâ€™erreur **actionnables** ; logs structurÃ©s (niveau + contexte).  
- **Fail-fast** plutÃ´t que silencieux.

# ğŸ” SÃ‰CURITÃ‰ (SHIFT-LEFT)
- **Jamais** de secrets/credentials en dÃ©pÃ´t.  
- **Proposer** dâ€™activer secret-scanning (Gitleaks ou git-secrets) en prÃ©-commit/CI.  
- Si ajout de variables sensibles : guider vers gestion via env/secret manager ; **jamais** les insÃ©rer dans le code ou lâ€™historique.

# ğŸ”„ GIT & REVUE
- **Interdit** de pousser sur `main`.  
- **Proposer** (si absent) : Protected Branches avec **required status checks** (tests, lint), **review requise**, **CODEOWNERS** sur zones critiques.  
- Commits : **Conventional Commits** ; versionnage **SemVer** ; changelog tenu (gÃ©nÃ©ration possible outillÃ©e).  
- Revue : vÃ©rifier **design**, **fonctionnalitÃ©**, **simplicitÃ©**, **tests**, **noms**, **sÃ©curitÃ©**.

# ğŸš€ CURSOR â€” BONNES PRATIQUES
- Toujours prÃ©ciser : **pÃ©rimÃ¨tre exact**, fichiers cibles, sortie attendue (**diff/snippets**).  
- Composer les `@` pour actions complexes (ex : `@workspace` + `@file` + `@terminal`).  
- **Refuser** toute action hors-scope ; **demander confirmation** avant tout refactor global.